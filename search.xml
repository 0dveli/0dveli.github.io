<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表知识点</title>
      <link href="/2025/02/12/%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/12/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络常识</title>
      <link href="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的简单构成"><a href="#计算机网络的简单构成" class="headerlink" title="计算机网络的简单构成"></a>计算机网络的简单构成</h1><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><p><strong>路由器（Router)</strong></p><p>是一种用于连接不同网络并转发数据包的网络设备。它的主要功能是在互联网协议（IP）网络之间路由数据包，从而使得不同网络上的设备能够相互通信。路由器工作在网络层（OSI模型的第三层，后面会具体介绍），可以根据IP地址和路由表来决定数据的最佳路径。</p><p><strong>路由器接法示意图</strong></p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/luyouqi.jpg" class="" title="路由器"><p>简单来说，路由器就像是一个快递站，负责收发“快递”，生活中我们是通过各个快递站来连接起了各个用户，形成“物流网”，而路由器就是网络世界的“快递站”，通过接收转发“数据包”来连接起了网络中的各个设备，形成了“互联网”；路由转发功能</p><p>但是路由器接口有限,不能支撑大量的设备接入;所以引出交换机设备</p><p><strong>交换机（Switch）</strong></p><p>是一种网络设备，用于在一个局域网（LAN）内连接多个设备，并促进它们之间的通信。交换机工作在数据链路层（OSI模型的第二层）。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><h4 id="ARP的工作位置"><a href="#ARP的工作位置" class="headerlink" title="ARP的工作位置"></a><strong>ARP的工作位置</strong></h4><p>ARP（Address Resolution Protocol,地址解析协议）工作在网络层和数据链路层之间，属于OSI七层模型中的数据链路层。它负责将IP地址解析为MAC地址。</p><h4 id="ARP的作用"><a href="#ARP的作用" class="headerlink" title="ARP的作用"></a><strong>ARP的作用</strong></h4><p>ARP的主要作用是将IP地址解析为MAC地址。在局域网（LAN）中，设备之间通过MAC地址进行通信，而IP地址用于标识设备在网络中的逻辑位置。ARP协议确保IP地址能够被正确地映射到对应的MAC地址。</p><h4 id="ARP的工作过程"><a href="#ARP的工作过程" class="headerlink" title="ARP的工作过程"></a><strong>ARP的工作过程</strong></h4><p>假设局域网内的主机A（IP地址为192.168.8.137）要访问主机B（IP地址为192.168.8.136）的80端口服务，以下是ARP的工作过程：</p><p><strong>检查ARP缓存</strong></p><ul><li>主机A首先检查本地的ARP缓存，看是否已经存在主机B的MAC地址。如果存在，直接使用缓存中的MAC地址进行通信。</li><li>如果ARP缓存中没有主机B的MAC地址，主机A将发起ARP请求。</li></ul><p><strong>ARP请求</strong></p><ul><li>主机A发送一个ARP请求广播报文，询问“IP地址为192.168.8.137的设备，你的MAC地址是什么？”。</li><li>ARP请求报文包含以下信息：<ul><li>源IP地址：192.168.8.137</li><li>源MAC地址：A的MAC地址</li><li>目的IP地址：192.168.8.136</li><li>目的MAC地址：00:00:00:00:00:00</li></ul></li></ul><p><strong>ARP响应</strong></p><ul><li>局域网内的所有设备都会收到这个ARP请求广播报文，但只有IP地址为192.168.11.9的主机B会响应。</li><li>主机B发送一个ARP响应报文，告诉主机A它的MAC地址。</li><li>ARP响应报文包含以下信息：<ul><li>源IP地址：192.168.8.136</li><li>源MAC地址：B的MAC地址</li><li>目的IP地址：192.168.8.137</li><li>目的MAC地址：A的MAC地址</li></ul></li></ul><p><strong>更新ARP缓存</strong></p><ul><li>主机A收到主机B的ARP响应后，将主机B的IP地址和MAC地址的映射关系存储在本地的ARP缓存中，以便后续通信时直接使用，无需再次广播请求。(<strong>ARP缓存表具有时效性大约是20-45秒左右</strong>)</li></ul><p><strong>数据传输</strong></p><ul><li>主机A使用主机B的MAC地址将数据封装成帧，通过数据链路层发送给主机B。</li><li>数据链路层在帧头中添加目的MAC地址（B的MAC地址）、源MAC地址（A的MAC地址）和协议类型，帧尾中添加FCS（帧检验序列）。</li></ul><h4 id="帧的封装"><a href="#帧的封装" class="headerlink" title="帧的封装"></a><strong>帧的封装</strong></h4><p>数据链路层在网络层的基础上封装了帧头和帧尾，具体如下：</p><ul><li><strong>帧头</strong>：<ul><li><strong>目的MAC地址</strong>：接收方的MAC地址（B的MAC地址）。</li><li><strong>源MAC地址</strong>：发送方的MAC地址（A的MAC地址）。</li><li><strong>协议类型</strong>：标识上层协议类型（如IP协议）。</li></ul></li><li><strong>帧尾</strong>：<ul><li><strong>FCS（帧检验序列）</strong>：用于检测帧在传输过程中是否出现错误。</li></ul></li></ul><h4 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a><strong>帧定界</strong></h4><p>帧头和帧尾共同组成帧定界，帮助接收方从比特流中准确提取帧。帧定界确保数据能够正确地被接收方识别和处理。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li><strong>ARP</strong>：工作在网络层和数据链路层之间，负责将IP地址解析为MAC地址。</li><li><strong>帧封装</strong>：数据链路层在网络层的基础上封装了帧头和帧尾，确保数据能够可靠地传输到相邻节点。</li><li><strong>帧定界</strong>：帧头和帧尾共同组成帧定界，帮助接收方从比特流中准确提取帧。</li></ul><p>通过上述过程，主机A能够成功地将数据发送给主机B，而无需每次都进行ARP广播请求。ARP缓存的存在大大提高了通信效率。</p><p>ARP通信</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%B8%BB%E6%9C%BAA.png" class="" title="A"><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%B8%BB%E6%9C%BAB.png" class="" title="B"><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/wireshark%E6%8A%93%E5%8C%85.png" class="" title="wireshark抓包"><p>137向136发起ping请求；136向137ping响应</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B1%80%E5%9F%9F%E7%BD%91ARP%E8%AF%B7%E6%B1%82.png" class="" title="局域网ARP请求"><p>ARP请求中的目标MAC地址设置为全零，表示发送方还不知道目标IP地址对应的MAC地址，需要通过ARP请求来获取。（未知）</p><p>以太网帧结构中，目标MAC地址字段用于指定帧的接收者。当目标MAC地址为广播地址（<code>FF:FF:FF:FF:FF:FF:FF:FF</code>）时，局域网内的所有设备都会接收这个帧。然而，**ARP请求的目的并不是发送给所有设备，而是查询特定IP地址对应的MAC地址。**因此，使用全零地址表示这是一个查询请求，而不是广播通信。</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ARP%E5%93%8D%E5%BA%94.png" class="" title="ARP响应"><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp -a   查看arp缓存表<br>arp -d  主机ip  删除arp缓存项但是需要权限<br></code></pre></td></tr></table></figure><p>arp要注意的</p><ul><li>arp欺骗，广播的时候计算机默认是诚实的，但是如果他不诚实，就可以做到欺骗</li><li>如果局域网规模太大，广播风暴</li></ul><p>arp欺骗，属于局域网的一种工具手段，但是win10及以上的系统基本上已经没有用了</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%92%E5%88%86%E5%B9%BF%E6%92%AD%E5%9F%9F.png" class="" title="路由器划分广播域"><p>现在有很多专门的arp安全工具，比如360的arp防护墙，也叫做局域网防护</p><p>广播风暴：</p><p>如果交换机连接的主机太多，那么一次广播就很耗资源，如果广播次数很多，那么就容易成堵塞。</p><p>解决方案：</p><ul><li>路由器配合ip地址段来进行广播域的划分，路由器的内网ip地址，也就是我们ipconfig命令查看网关ip地址一般都是网段的第一个地址和最后一个ip</li></ul><h3 id="arpspoof工具ARP欺骗实验"><a href="#arpspoof工具ARP欺骗实验" class="headerlink" title="arpspoof工具ARP欺骗实验"></a>arpspoof工具ARP欺骗实验</h3><p>kali系统有一个arp欺骗攻击工具<strong>arpspoof</strong>      做个小小的实验</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sudo arpspoof -i ens33 -t 192.168.8.136 192.168.8.1<br></code></pre></td></tr></table></figure><ul><li><strong><code>-i &lt;interface&gt;</code></strong>：指定网络接口，例如 <code>ens33</code>。</li><li><strong><code>-t &lt;target&gt;</code></strong>：指定目标主机的 IP 地址。这是你想要欺骗的设备的 IP 地址。</li><li><strong><code>&lt;host&gt;</code></strong>：指定被欺骗的主机的 IP 地址。通常是网关的 IP 地址或其他设备的 IP 地址。</li></ul><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/arpspoof%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8Carp%E6%AC%BA%E9%AA%97.png" class="" title="arpspoof工具进行arp欺骗"><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/wireshark%E6%AC%BA%E9%AA%97%E6%A3%80%E9%AA%8C.png" class="" title="wireshark欺骗检验"><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%97%E5%AE%B3%E8%80%85%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8F%97%E5%88%B0%E5%81%87%E7%9A%84mac%E5%9C%B0%E5%9D%80.png" class="" title="受害者的机器受到假的mac地址"><p>实验成功！</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><hr><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>TCP(Transmission Control Protocol)传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，在 OSI 模型中完成传输层指定功能。 TCP 使用<strong>校验和函数</strong>检验数据是否出现错误，在数据发送和接收时均需要计算<strong>校验和</strong>。</p><hr><h4 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h4><p><strong>1.TCP 是面向连接的传输层协议</strong></p><blockquote><p> 应用程序在使用 TCP 协议前，必须首先完成 TCP 连接的建立。在数据传输结束后，必须释放先前已建立的 TCP 连接</p></blockquote><p><strong>2.每一条 TCP 连接只能有两个端点</strong></p><blockquote><p> TCP 连接只能是点对点，一对一的</p></blockquote><p><strong>3.TCP 提供可靠交付服务</strong></p><blockquote><p> 通过 TCP 连接传送的数据，无差错、不丢失、不重复，且按序到达</p></blockquote><p><strong>4.TCP 提供全双工通信</strong></p><blockquote><p> TCP 允许通信双方的应用进程在<strong>任何时候</strong>都可以发送数据，TCP连接的两端都设有<strong>发送、接收缓存</strong>，用于临时存放双向通信的数据，上层应用进程在时机恰当时会读取缓存中的数据</p></blockquote><p><strong>5.TCP 面向字节流</strong></p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/tcp%E5%AD%97%E8%8A%82%E6%B5%81%E5%9B%BE.png" class=""><p> <strong>流</strong>是指：流入到进程或从进程流出的<strong>字节序列</strong> TCP 把应用程序回传的数据看做一连串的<strong>无结构</strong>的字节流，不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系 接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一致，且接收方的应用程序必须具有识别接收字节流，并将其还原为有意义的应用层数据的能力</p><hr><h4 id="TCP-报文首部"><a href="#TCP-报文首部" class="headerlink" title="TCP 报文首部"></a>TCP 报文首部</h4><p>这里需要了解 TCP 报文首部的格式，相关<strong>控制位</strong>非常重要</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8.png" class=""><blockquote><p> 由于 TCP 报文段首部的前 20 个字节是固定的，其后 4n 个字节是根据需要增加的选项，所以 TCP首部的最小长度是 20 字节</p></blockquote><p><strong>1.源端口和目的端口</strong></p><blockquote><p> 各占 2 字节，分别写入源端口号、目的端口号</p></blockquote><p><strong>2.序号字段</strong></p><blockquote><p> 占 4 字节，范围为 <code>[0，2 ^ 32-1]</code>，序号使用 <code>mod2^32</code> 运算，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置，首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号</p></blockquote><p><strong>3.确认号字段</strong></p><blockquote><p> 占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号等于 N，则表明：到序号 N-1 为止数据均己正确接收</p></blockquote><p><strong>4.数据偏移字段</strong></p><blockquote><p> 占 4 位，指出 TCP 报文段的数据起始处和 TCP 报文段的起始处的距离。此字段实际上指出了 TCP 报文段的首部长度 </p></blockquote><p><strong>5.保留字段</strong></p><blockquote><p> 占 6 位，保留为今后使用，目前应置为0 </p></blockquote><p><strong>6.紧急 URG</strong></p><blockquote><p> URG&#x3D;1时，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送，即提高数据传送的优先级 </p></blockquote><p><strong>7.确认 ACK</strong></p><blockquote><p> 仅当 ACK&#x3D;1 时确认号字段才有效，TCP 规定，在连接建立后所有传送的报文段必须将 ACK 置为 1 </p></blockquote><p><strong>8.推送 PSH</strong></p><blockquote><p> 接收 TCP 收到 PSH&#x3D;1 的报文段后，将尽快交付接收的应用进程，不再等到缓存都填满后再继续向上交付 </p></blockquote><p><strong>9.复位 RST</strong></p><blockquote><p> 当 RST&#x3D;1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接。也可以用于拒绝一个非法的报文段或拒绝打开一个连接 </p></blockquote><p><strong>10.同步 SYN</strong></p><blockquote><p> 连接建立时用来同步序号，SYN&#x3D;1就表示这是一个连接请求或连接接受报文 </p></blockquote><p><strong>11.终止 FIN</strong></p><blockquote><p> 用于释放一个连接，当 FIN&#x3D;1 时，表明此报文段的发送方的数据己发送完毕，并要求释放传输连接 </p></blockquote><p><strong>12.窗口字段</strong></p><blockquote><p> 占 2 字节，窗口值范围为 <code>[0，2^16-1]</code> 之间的整数。窗口是指发送本报文段的一方的接收窗口，窗口值作为接收方让发送方设置其发送窗口的依据 </p></blockquote><p><strong>13.检验和字段</strong></p><blockquote><p> 占 2 字，检验和字段检验的范围包括首部和数据两部分 </p></blockquote><p><strong>14.紧急指针</strong></p><blockquote><p> 占 2 字节，仅当 URG&#x3D;1 时才有意义，含义是：本报文段中的紧急数据的字数，紧急指针指出了紧急数据的末尾在报文段中的位置 当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。注意：即使窗口为零时也可发送紧急数据 </p></blockquote><p><strong>15.选项字段</strong></p><blockquote><p> 长度可变，最长可达 40 字节。未使用“选项”时，TCP 首部长度为 20 字节 </p></blockquote><hr><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP协议再发送数据包的时候，会发送多种类型的数据包，每种数据包都有特殊意义，每个数据包都在数据包里添加特定的标识数据来表示数据包的意义，例如：</p><ul><li>SYN    建立连接</li><li>ACK    回应标识</li><li>FIN     断开连接</li><li>PSH    数据包</li><li>RST    重复（重传）网络不稳定的时候会看到好多重发包</li><li>URG   紧急指针</li></ul><h5 id="TCP建立连接需要三次握手"><a href="#TCP建立连接需要三次握手" class="headerlink" title="TCP建立连接需要三次握手"></a>TCP建立连接需要三次握手</h5><p>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；<br>2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号seq&#x3D;x，此时，TCP客户端进程进入了SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。<br>3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。<br>4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自已的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入<br>ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p><p> 5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p><h5 id="三次握手流程图"><a href="#三次握手流程图" class="headerlink" title="三次握手流程图"></a><strong>三次握手流程图</strong></h5><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class="" title="TCP三次握手"><p>ack&#x3D;x+1是指对seq&#x3D;x的序列号进行确认表示下一次想要接收到客户端发送学烈火为seq&#x3D;x+1;</p><p>ACK&#x3D;1:表示这个确认报文段是有效的；</p><hr><p><strong>三次握手比作两个朋友见面？</strong></p><p>你好你是张三嘛？</p><p>我是张三;你是李四嘛？</p><p>我是李四？</p><hr><h5 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h5><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一次请求连接并且没用丢失，只是因为再网络结点中滞留的时间太长，由于TCP的客户端迟迟没有收到确认保温，以为服务器没用收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接，此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个保温本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误的资源浪费</p><p>在 TCP 协议中，<strong>ACK</strong> 和 <strong>ack</strong> 有明确的区别，主要体现在它们的作用和含义上：</p><ol><li><strong>ACK（大写）</strong></li></ol><ul><li><strong>含义</strong>：ACK 是 TCP 报文段中的一个标志位（Flag），表示<strong>确认号</strong>（Acknowledgement Number）字段是否有效</li></ul><p><strong>作用</strong>：</p><ul><li><p>当 ACK&#x3D;1 时，确认号字段有效，表示这是一个确认报文</p></li><li><p>在 TCP 三次握手过程中，ACK 标志位用于确认连接请求或响应</p></li><li><p>在数据传输阶段，ACK 标志位用于确认收到的数据</p></li></ul><ol start="2"><li><strong>ack（小写）</strong></li></ol><ul><li><strong>含义</strong>：ack 是确认号（Acknowledgement Number）的缩写，表示<strong>接收方期望收到的下一个数据字节的序号</strong></li></ul><p><strong>作用</strong>：</p><ul><li>ack 值用于告知发送方，接收方已经成功收到的数据字节范围</li></ul><p>例如，<strong>如果 ack&#x3D;501，表示接收方已经收到序号为 1 到 500 的所有字节，期望收到序号为 501 的字节</strong></p><p>在三次握手过程中，ack 值表示接收方已经收到序号为1-ack-1字节，并告知发送方下一个期望的序号ack</p><hr><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>当建立一个TCP连接，服务端再LISTEN状态下，收到建立连接请求的SYN报文后，服务端将将ACK和SYN存放到同一个报文中一起发送给客户端</p><p>而关闭连接时，服务端收到客户端的FIN报文时，仅表示对方不在发送数据，但仍然能够接收数据，此时，服务端不一定将全部数据都发送给了客户端</p><p>因此服务端关闭有两种方式：</p><ul><li>立即关闭</li><li>继续发送一些数据给客户端后，再发送FIN报文给客户端（表示统一关闭连接），是否立刻关闭发送数据通道，需要交给上层应用决定，所以，客户端的ACK和FIN一般都会分开发送，这里会导致次数增加一</li></ul><p>数据传输完毕后，双方均可释放连接，起初，客户端和服务端均处于ESTABLISHED状态，然后客户端主动关闭，服务端被动关闭；</p><h5 id="TCP释放连接四次挥手示意图"><a href="#TCP释放连接四次挥手示意图" class="headerlink" title="TCP释放连接四次挥手示意图"></a>TCP释放连接四次挥手示意图</h5><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class=""><p>字符注释：</p><ul><li>FIN:连接终止位</li><li>seq:发送的第一个字节的序号</li><li>ACK:确认报文段</li><li>ack:确认号</li></ul><h5 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h5><ul><li>客户端发送<strong>第一次挥手</strong>，之后由 <code>ESTABLISHED</code> 状态转为 <code>FIN_WAIT1</code> 状态 </li><li>服务器收到客户端的第一次挥手之后，发送<strong>第二次挥手</strong>给服务器，服务器进入 <code>CLOSE_WAIT</code> 状态，等待服务器自身的 <code>SOCKET</code> 关闭等处理 </li><li>客户端收到服务器的第二次挥手，进入 <code>FIN_WAIT2</code> 状态，等待服务器关闭 </li><li>服务器发送<strong>第三次挥手</strong>，然后进入 <code>LAST_ACK</code> 状态 </li><li>客户端收到第三次挥手，发送<strong>第四次挥手</strong>，客户端进入 <code>TIME_WAIT</code> 状态； </li><li>服务器收到第四次挥手，进入 <code>CLOSED</code> 状态，客户端等待 <strong>2MSL</strong> 后，进入 <code>CLOSED</code> 状态</li></ul><h5 id="TCP连接和释放示意图"><a href="#TCP连接和释放示意图" class="headerlink" title="TCP连接和释放示意图"></a>TCP连接和释放示意图</h5><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%87%8A%E6%94%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class=""><h2 id="DNS（53）"><a href="#DNS（53）" class="headerlink" title="DNS（53）"></a>DNS（53）</h2><h3 id="DNS的定义和由来"><a href="#DNS的定义和由来" class="headerlink" title="DNS的定义和由来"></a>DNS的定义和由来</h3><p>DNS(Domain Name System)域名系统</p><ul><li>作用：将域名解析成IP地址</li></ul><p>计算机和计算机之间通信是通过ip:端口来实现的。</p><p>比如：192.168.19.36:51000&lt;–&gt;1922.168.19.40:80</p><p>服务端的某些服务程序的端口一般是固定的，客户端根据ip和端口进行连接通信，客户端的ip是固定的，但是端口一般是系统随机分配的。（前提客户端不刻意改和DHCP协议不自动分配ip（防止原来ip被人占用））</p><p>ip是很难记住的，一个两个还行，多了根本记不住，而且如果某个网站的ip地址变了，那么就要重新记忆一下新的ip地址，导致ip地址这个东西其实轻易不能变，变了别人就找不到这个网站了，后来有人开发一个程序，这个程序类似于电话本</p><p>域名&lt;–&gt;电话号的名字</p><p>ip&lt;–&gt;电话号</p><p>然后它访问某个网站的时候，就让浏览器自动来读取这个电话本，自动帮他找到名字对应的ip地址来进行访问。</p><p>这个电话本至今还保留，windows里面就是<strong>C:\Windows\System32\drivers\etc\hosts</strong>文件</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IP%E7%94%B5%E8%AF%9D%E6%9C%AC.png" class=""><p>当访问域名:4000的时候就可访问192.168.1.13:4000的服务;验证成功了！</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%9F%E5%90%8D%E9%AA%8C%E8%AF%81.png" class=""><p>修改的时候常规有三种情况不好使</p><ul><li>本地开代理</li><li>浏览器和DNS缓存表有缓存   刷新一下就行</li><li>权限不够</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">浏览器刷新ctrl+F5<br>ipconfig /flushdns<br></code></pre></td></tr></table></figure><p>这个电话本程序被大佬分享出来了，所有人都可以使用他这个程序来访问网站，因此不需要记住ip地址，所以现在我们的电脑上都有了这个电话本程序和它对应的文件hosts，而且在特定的目录下面</p><p>并且网上有几个专门的网站提供最新的hosts文件，比如8.8.8.8&#x2F;114.114.114.114这个网站，我们可以去这个网站下载最新的hosts文件代替我们自己电脑的hosts文件，那么最新的网站都可以通过这个域名访问</p><p>但是通过更新hosts文件的方式并不是太好，所有的用户都要自行去下载最新的hosts文件来更新，而且也不知道什么时候更新，要经常去下载，并且如果Hosts文件比较大，下载也慢，所以就出现我们说的DNS服务器</p><p>常用的DNS服务器地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">国内：<br><br>​       阿里云：<br><br>​               223.5.5.5<br><br>​               223.6.6.6<br><br>​        百度：180.76.76.76<br><br>​        腾讯：119.29.29.29<br><br>​        南京信风：114.114.114.114   （广告多不建议使用）<br><br>国外： <br><br>​        谷歌：8.8.8.8<br></code></pre></td></tr></table></figure><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E5%99%A8DNS%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class=""><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%AE%E6%94%B9DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80.png" class=""><ul><li>在命令提示符中输入  ipconfig&#x2F;all</li></ul><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/DNS.png" class=""><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig /displaydns<br></code></pre></td></tr></table></figure><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%9F%A5%E7%9C%8Bdns%E7%BC%93%E5%AD%98%E8%AE%B0%E5%BD%95.png" class=""><hr><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" class=""><p>顺序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1、找本机的hosts文件windows的hosts文件路径：c：\windows\system32\drivers\etc\hosts，hosts文件以静态映射的方式提供IP地址与主机名的对照表。<br>2、浏览器缓存：浏览器会按照一定的频率缓存DNS记录。浏览器地址栏输入chrome://net-internals/#dns，就可以查看chormeDNS缓存。 3、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。cmd命令ipconfig/displaydns用于查看操作系统dns缓<br>存。ipconfig/flushdns刷新缓存，之前的记录就没了，只剩下一些固定的了。 4、路由缓存：路由器也有DNS缓存。<br>5、去DNS本地服务器查找，自己公司搭建的或者阿里DNS服务器、百度DNS服务器等等<br>6、去根域名服务器上找，全世界有13台根域名服务器，其实我们的网址，比如www.xr0day.com后面都有个点.，这个.代表根域名的意思，我们可以 ns1ookup www.xr0day.com，发现还是可以查询到的，只不过这个.默认省略掉了。<br>7、根域名查不到的话，会直接下发本次请求给本地DNS服务器，并且把.com的项级域名服务器地址发送给它，DNS服务器再向.com顶级域名服务器来进行查询。，com\.cn\.cloud等都是顶级域名服务器。<br>8、如果，com找不到的话，，com顶级域名服务器会给本地DNS服务器下发请求，并且给它xr0day.com域名服务器的地址，意思就是说xr0day这个域名下放给xr0day这个域名所属公司的DNS服务器了，那么就去xr0day.com域名服务器进行查询<br>9、查找到之后再还给你的电脑，你的电脑本地和路由器等都会自动缓存这些记录，下次再访问这个网站的时候，就从缓存中找，不然每次都按照流程找一遍就太慢了。<br></code></pre></td></tr></table></figure><p>在google浏览器URL输入：chrome:&#x2F;&#x2F;net-internals&#x2F;#dns</p><p>输入<a href="http://www.xr0day.com域名查找,查找结果正是我的局域网ip地址/">www.xr0day.com域名查找,查找结果正是我的局域网ip地址</a></p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/google%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AE%B0%E5%BD%95.png" class=""><p>两种查询： 递归查询，迭代查询</p><p>所有的DNS服务器解析DNS权力都是由上级DNS服务器授权的，最终是跟服务器授权，着这些权力根据服务器是可以回收来自己解析的，当年美国攻打伊拉克，让伊拉克在互联网上消失了，就玩了一手DNS解析，将所有伊拉克的网站网址解析到一个错误的ip地址上，别人都访问不了伊拉克的网站了。</p><p>13个跟域名服务器，其中一个为主根服务器在美国，由美国互联网机构Network solution运作，其他12个为辐根服务器，其中9个在美国，2个在欧洲（位于英国和瑞典），一个在亚洲（日本）</p><p>在与现有IPv4根服务器体系架构充分兼容基础上，“雪人计划“于2016年在全球16个国家完成25台IPv6根服务器架设，事实上形成了13台原有根加25台IPv6根的新格局，为建立多边、民主、透明的国际互联网治理体系打下坚实基础。中国部署了其中的4台，由1台主根服务器和3台辅根服务器组成，打破了中国过去没有根服务器的困境。所以中国现在主推ipv6。</p><hr><h3 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">linux上的DNS相关命令<br>dig  @DNS服务器(8.8.8.8) 域名<br>nslookup 域名    DNS服务器(8.8.8.8)<br>host  域名 DNS服务器(8.8.8.8)<br>ping www.baidu.com   也会看到域名解析出的ip<br></code></pre></td></tr></table></figure><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E7%9A%84%E5%91%BD%E4%BB%A4.png" class=""><hr><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>一是国家和地区顶级域名（country code top-level domains，简称ccTLDs），目前200多个国家都按照ISO3166国家代码分配了项级域名，例如中国是cn，日本是jp等；<br>二是国际顶级域名（generic top-level domains，简称gTLDs），例如表示工商企业的.com域名，表示网络提供商的.net域名，表示非盈利组织的，org域名等：<br>三是新项级域名（New Generic Top-level Domain，简称New gTLD）如通用的.xyz域名、代表“高端”的.top域名、代表“红色”的.red域名、代表“人”的.men域名等一千多种。<br>从技术角度来看，一个完整的域名由顶级域名和下级域名构成，各部分之间用”.”隔开，最后一个“.”的右边被称为顶级域名（TLD，也称为一级域名），“.”左边的部分被称为二级域名，二级域名的左边是三级域名，以此类推。<br>为了便于理解和交流，我们通常会把域名分为前缀+后缀，后级一般就是我们常见的.com&#x2F;.cn&#x2F;.cc&#x2F;.net等等，这些都属于顶级域名，前级则是由数字、字母自由组成的，用以和其他域名相区分的部分，这部分也是域名的核心价值所在。</p><p>举个例子，中科三方的官网为<a href="http://www.sfn.cn/">http://www.sfn.cn</a></p><p>这其中.cn为顶级域名，也就是人们常说的后缀部分，sfn则是其前缀的二级域名部分，代表的是中科三方这个品牌，最前面的.www则是前缀的三级域名部分，代表的是中科三方的官网。<br>业务再这个二级域名基础上无限定义三级域名或更高级的域名，</p><ul><li><p>比如，小米云服务：<a href="http://i.mi.com/">http://i.mi.com</a></p></li><li><p>小爱开放平台：<a href="http://xiaoai.mi.com/">http://xiaoai.mi.com</a></p></li><li><p>小米iot开发者平台：<a href="http://iot.mi.com/">http://iot.mi.com</a></p></li><li><p>小米金融：<a href="http://jr.mi.com/">http://jr.mi.com</a></p><p>除了政府相关网站外，很少有企业去定义三级以上的域名。</p></li></ul><hr><h3 id="DNS记录的类型"><a href="#DNS记录的类型" class="headerlink" title="DNS记录的类型"></a>DNS记录的类型</h3><ul><li>A-将域名指向—个IPV4地址</li><li>CNAME-将域名指向另外—个域名</li><li>AAAA-将域名指向—个IPV6地址</li><li>NS-将子域名指他DNS服务器解析</li><li>MX-将域名指向邮件服务器地址</li><li>SRV-记录提供特定的服务的服务器</li><li>TXT-文本长度限制512，通常做SPF记录（反垃圾邮件） </li><li>CAA-CA证书颁发机构授权校验</li></ul><hr><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><h3 id="1-基本扫描"><a href="#1-基本扫描" class="headerlink" title="1. 基本扫描"></a><strong>1. 基本扫描</strong></h3><h5 id="扫描单个主机"><a href="#扫描单个主机" class="headerlink" title="扫描单个主机"></a>扫描单个主机</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="扫描多个主机"><a href="#扫描多个主机" class="headerlink" title="扫描多个主机"></a>扫描多个主机</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 192.168.1.1 192.168.1.2<br></code></pre></td></tr></table></figure><h5 id="扫描网段"><a href="#扫描网段" class="headerlink" title="扫描网段"></a>扫描网段</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 192.168.1.0/24<br></code></pre></td></tr></table></figure><h3 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2. 端口扫描"></a><strong>2. 端口扫描</strong></h3><h5 id="扫描指定端口"><a href="#扫描指定端口" class="headerlink" title="扫描指定端口"></a>扫描指定端口</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -p 80,443 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="扫描端口范围"><a href="#扫描端口范围" class="headerlink" title="扫描端口范围"></a>扫描端口范围</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -p 1-1000 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="扫描所有端口"><a href="#扫描所有端口" class="headerlink" title="扫描所有端口"></a>扫描所有端口</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -p- 192.168.1.1<br></code></pre></td></tr></table></figure><h3 id="3-扫描方式"><a href="#3-扫描方式" class="headerlink" title="3. 扫描方式"></a><strong>3. 扫描方式</strong></h3><h5 id="TCP-全连接扫描"><a href="#TCP-全连接扫描" class="headerlink" title="TCP 全连接扫描"></a>TCP 全连接扫描</h5><p>三次握手看State状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sT -p 80 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="SYN-半连接扫描"><a href="#SYN-半连接扫描" class="headerlink" title="SYN 半连接扫描"></a>SYN 半连接扫描</h5><p>两次握手看State状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sS -p 80 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="隐秘扫描"><a href="#隐秘扫描" class="headerlink" title="隐秘扫描"></a>隐秘扫描</h5><p>好的，我来详细解释这些命令的含义和用途。</p><h6 id="1-FIN-扫描-sF"><a href="#1-FIN-扫描-sF" class="headerlink" title="1. FIN 扫描 (-sF)"></a>1. <strong>FIN 扫描 (<code>-sF</code>)</strong></h6><p>bash复制</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 127.0.0.1 -p 80 -sF<br></code></pre></td></tr></table></figure><ul><li><strong><code>-sF</code></strong>：进行 FIN 扫描。<ul><li><strong>原理</strong>：发送一个仅包含 FIN 标志的 TCP 数据包到目标端口。</li><li><strong>响应</strong>：<ul><li>如果目标端口是 <strong>关闭的</strong>，目标主机通常会回复一个 RST（重置）数据包。</li><li>如果目标端口是 <strong>开放的</strong>，目标主机通常不会回复任何数据包。</li></ul></li><li><strong>用途</strong>：这种扫描方式可以绕过某些防火墙的检测，因为某些防火墙可能不会对 FIN 数据包进行响应。</li><li><strong>结果</strong>：<ul><li>如果收到 RST 数据包，端口状态为 <strong>closed</strong>。</li><li>如果没有收到任何响应，端口状态为 <strong>open|filtered</strong>（开放或被过滤）。</li></ul></li></ul></li></ul><h6 id="2-Null-扫描-sN"><a href="#2-Null-扫描-sN" class="headerlink" title="2. Null 扫描 (-sN)"></a>2. <strong>Null 扫描 (<code>-sN</code>)</strong></h6><p>bash复制</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 127.0.0.1 -p 80 -sN<br></code></pre></td></tr></table></figure><ul><li><strong><code>-sN</code></strong>：进行 Null 扫描。<ul><li><strong>原理</strong>：发送一个没有任何标志（即所有标志位都为 0）的 TCP 数据包到目标端口。</li><li><strong>响应</strong>：<ul><li>如果目标端口是 <strong>关闭的</strong>，目标主机通常会回复一个 RST 数据包。</li><li>如果目标端口是 <strong>开放的</strong>，目标主机通常不会回复任何数据包。</li></ul></li><li><strong>用途</strong>：这种扫描方式也可以绕过某些防火墙的检测，因为某些防火墙可能不会对这种特殊的数据包进行响应。</li><li><strong>结果</strong>：<ul><li>如果收到 RST 数据包，端口状态为 <strong>closed</strong>。</li><li>如果没有收到任何响应，端口状态为 <strong>open|filtered</strong>（开放或被过滤）。</li></ul></li></ul></li></ul><h6 id="3-Xmas-扫描-sX"><a href="#3-Xmas-扫描-sX" class="headerlink" title="3. Xmas 扫描 (-sX)"></a>3. <strong>Xmas 扫描 (<code>-sX</code>)</strong></h6><p>bash复制</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap 127.0.0.1 -p 80 -sX<br></code></pre></td></tr></table></figure><ul><li><strong><code>-sX</code></strong>：进行 Xmas 扫描。<ul><li><strong>原理</strong>：发送一个包含 FIN、URG 和 PSH 标志的 TCP 数据包到目标端口。</li><li><strong>响应</strong>：<ul><li>如果目标端口是 <strong>关闭的</strong>，目标主机通常会回复一个 RST 数据包。</li><li>如果目标端口是 <strong>开放的</strong>，目标主机通常不会回复任何数据包。</li></ul></li><li><strong>用途</strong>：这种扫描方式也可以绕过某些防火墙的检测，因为某些防火墙可能不会对这种特殊的数据包进行响应。</li><li><strong>结果</strong>：<ul><li>如果收到 RST 数据包，端口状态为 <strong>closed</strong>。</li><li>如果没有收到任何响应，端口状态为 <strong>open|filtered</strong>（开放或被过滤）。</li></ul></li></ul></li></ul><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>这些扫描方式（FIN 扫描、Null 扫描和 Xmas 扫描）都属于隐秘扫描技术，主要用于绕过某些防火墙的检测。它们通过发送特殊的 TCP 数据包来探测目标端口的状态。这些扫描方式的共同点是：</p><ul><li>如果目标端口是 <strong>关闭的</strong>，目标主机通常会回复一个 RST 数据包。</li><li>如果目标端口是 <strong>开放的</strong>，目标主机通常不会回复任何数据包。</li></ul><h3 id="4-主机探测"><a href="#4-主机探测" class="headerlink" title="4. 主机探测"></a><strong>4. 主机探测</strong></h3><h5 id="存活主机扫描"><a href="#存活主机扫描" class="headerlink" title="存活主机扫描"></a>存活主机扫描</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sn 192.168.1.0/24<br></code></pre></td></tr></table></figure><h3 id="5-服务识别"><a href="#5-服务识别" class="headerlink" title="5. 服务识别"></a><strong>5. 服务识别</strong></h3><h5 id="识别服务版本"><a href="#识别服务版本" class="headerlink" title="识别服务版本"></a>识别服务版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sV -p 80 192.168.1.1<br></code></pre></td></tr></table></figure><h3 id="6-系统识别"><a href="#6-系统识别" class="headerlink" title="6. 系统识别"></a><strong>6. 系统识别</strong></h3><h5 id="识别操作系统"><a href="#识别操作系统" class="headerlink" title="识别操作系统"></a>识别操作系统</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -O -p 80 192.168.1.1<br></code></pre></td></tr></table></figure><h3 id="7-扫描结果导出"><a href="#7-扫描结果导出" class="headerlink" title="7. 扫描结果导出"></a><strong>7. 扫描结果导出</strong></h3><h5 id="导出为文本格式"><a href="#导出为文本格式" class="headerlink" title="导出为文本格式"></a>导出为文本格式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -oN result.txt 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="导出为-XML-格式"><a href="#导出为-XML-格式" class="headerlink" title="导出为 XML 格式"></a>导出为 XML 格式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -oX result.xml 192.168.1.1<br></code></pre></td></tr></table></figure><h3 id="8-高级选项"><a href="#8-高级选项" class="headerlink" title="8. 高级选项"></a><strong>8. 高级选项</strong></h3><h5 id="快速扫描"><a href="#快速扫描" class="headerlink" title="快速扫描"></a>快速扫描</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -T4 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="慢速扫描"><a href="#慢速扫描" class="headerlink" title="慢速扫描"></a>慢速扫描</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -T1 192.168.1.1<br></code></pre></td></tr></table></figure><p><strong>从文件读取目标</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -iL targets.txt<br></code></pre></td></tr></table></figure><p>从文件中读取目标列表。</p><h5 id="UDP-扫描"><a href="#UDP-扫描" class="headerlink" title="UDP 扫描"></a>UDP 扫描</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sU -p 53,123 192.168.1.1<br></code></pre></td></tr></table></figure><h5 id="ICMP-扫描"><a href="#ICMP-扫描" class="headerlink" title="ICMP 扫描"></a>ICMP 扫描</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nmap -sP 192.168.1.0/24<br></code></pre></td></tr></table></figure><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p><code>-d</code></p><ul><li><strong>功能</strong>：不将节点主机名解析为 IP 地址，直接进行路由跟踪。</li><li><strong>用途</strong>：在某些情况下，DNS 解析可能会导致延迟或失败，使用 <code>-d</code> 可以跳过主机名解析，直接使用 IP 地址进行路由跟踪。</li></ul><p><code>-h maximum_hops</code></p><ul><li><strong>功能</strong>：指定最多经过多少个节点进行路由跟踪。</li><li><strong>默认值</strong>：30</li><li><strong>用途</strong>：限制路由跟踪的最大跳数，防止无限循环或超时。</li></ul><p><code>-j host-list</code></p><ul><li><strong>功能</strong>：枚举一个节点列表，并在路由跟踪过程中只走该列表中的节点。</li><li><strong>用途</strong>：指定路由跟踪必须经过的中间节点，适用于特定的网络路径测试。</li></ul><p><code>-w timeout</code></p><ul><li><strong>功能</strong>：设置等待每个回复消息的超时时间。</li><li><strong>默认值</strong>：4000 毫秒（4 秒）</li><li><strong>用途</strong>：设置每个节点的等待超时时间，防止因网络延迟导致的长时间等待。</li></ul><p><code>-R</code></p><ul><li><strong>功能</strong>：跟踪路由时，使用“参考路由”而不是“严格源路由”。</li><li><strong>用途</strong>：在某些网络环境中，某些路由器可能不支持严格源路由，使用“参考路由”可以绕过这些限制。</li></ul><p><code>-S srcaddr</code></p><ul><li><strong>功能</strong>：指定源地址。</li><li><strong>用途</strong>：如果计算机上安装了多个网卡，该选项可以指定从哪个网卡发出路由跟踪请求。</li></ul><p><code>-4</code></p><ul><li><strong>功能</strong>：强制使用 IPv4 进行路由跟踪。</li><li><strong>用途</strong>：确保路由跟踪使用 IPv4 协议。</li></ul><p><code>-6</code></p><ul><li><strong>功能</strong>：强制使用 IPv6 进行路由跟踪。</li><li><strong>用途</strong>：确保路由跟踪使用 IPv6 协议。</li></ul><p><code>target_name</code></p><ul><li><strong>功能</strong>：要查询的目标 IP 地址或主机名。</li><li><strong>用途</strong>：指定路由跟踪的目标地址。</li></ul><p>示例命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">traceroute -d -h 20 -w 5000 -S 192.168.1.100 -4 www.example.com<br></code></pre></td></tr></table></figure><ul><li><code>-d</code>：跳过主机名解析。</li><li><code>-h 20</code>：最大跳数为 20。</li><li><code>-w 5000</code>：超时时间为 5000 毫秒。</li><li><code>-S 192.168.1.100</code>：指定源地址为 <code>192.168.1.100</code>。</li><li><code>-4</code>：强制使用 IPv4。</li><li><code>www.example.com</code>：目标地址。</li></ul><hr><h2 id="VMware三种网络模式"><a href="#VMware三种网络模式" class="headerlink" title="VMware三种网络模式"></a>VMware三种网络模式</h2><table><thead><tr><th align="center">虚拟交换机</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">VMnet0</td><td align="center">桥接模式</td></tr><tr><td align="center">VMnet1</td><td align="center">仅主机模式</td></tr><tr><td align="center">VMnet8</td><td align="center">NAT模式</td></tr></tbody></table><h3 id="1-桥接模式（Bridged-Mode）"><a href="#1-桥接模式（Bridged-Mode）" class="headerlink" title="1. 桥接模式（Bridged Mode）"></a>1. 桥接模式（Bridged Mode）</h3><ul><li><strong>定义</strong>：虚拟机的虚拟网络适配器直接连接到主机的物理网络适配器，就像局域网中添加了一台新的独立计算机，基于物理机的网卡进行上网的。</li><li><strong>特点</strong>：<ul><li>虚拟机占用局域网中的一个 IP 地址（与物理机同一个网段的，为局域网的另一个设备）</li><li>可以与局域网中的其他终端进行相互访问。</li><li>支持有线和无线网络适配器。</li><li>适用于需要将虚拟机作为独立计算机进行网络通信的场景。</li></ul></li></ul><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A1%A5%E6%8E%A5.png" class=""><h3 id="2-NAT-模式（Network-Address-Translation）"><a href="#2-NAT-模式（Network-Address-Translation）" class="headerlink" title="2. NAT 模式（Network Address Translation）"></a>2. NAT 模式（Network Address Translation）</h3><ul><li><strong>定义</strong>：虚拟机通过主机的网络适配器访问外部网络，使用网络地址转换（NAT）技术。</li><li><strong>特点</strong>：<ul><li>虚拟机在外部网络中不需要自己的 IP 地址(与物理机不在一个网段上)。</li><li>虚拟机发送的数据包由 NAT 适配器加上特殊标记，并以主机的名义转发。</li><li>外部网络返回的数据包由 NAT 适配器根据标记转发给对应的虚拟机。</li><li>默认情况下，外部网络终端无法访问虚拟机。</li><li>适用于需要隔离虚拟机与外部网络的场景。</li></ul></li></ul><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NAT.png" class=""><h3 id="3-仅主机模式（Host-Only-Mode）"><a href="#3-仅主机模式（Host-Only-Mode）" class="headerlink" title="3. 仅主机模式（Host-Only Mode）"></a>3. 仅主机模式（Host-Only Mode）</h3><ul><li><strong>定义</strong>：虚拟机与主机系统之间提供网络连接，创建完全包含在主机中的专用网络。</li><li><strong>特点</strong>：<ul><li>虚拟网络适配器仅对主机可见。</li><li>默认情况下，虚拟机无法连接到 Internet。</li><li>可以通过在主机上安装路由或代理软件，或在 Windows 主机上使用 Internet 连接共享功能，使虚拟机连接到 Internet。</li><li>同一主机上可以创建多个仅主机模式的虚拟网络。</li><li>同一仅主机模式网络中的虚拟机可以相互通信，不同网络中的虚拟机默认无法通信（可通过设置路由器实现）。</li><li>适用于需要完全隔离虚拟机网络的场景。</li></ul></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>桥接模式</strong>：适用于需要虚拟机与局域网其他设备进行通信的场景。</li><li><strong>NAT 模式</strong>：适用于需要虚拟机访问外部网络，但不需要外部网络访问虚拟机的场景。</li><li><strong>仅主机模式</strong>：适用于需要完全隔离虚拟机网络的场景。</li></ul><h2 id="上不了网排查思路"><a href="#上不了网排查思路" class="headerlink" title="上不了网排查思路"></a>上不了网排查思路</h2><p>拿VMware举例子</p><p>1.查看网卡是否开启（绿灯代表开启了）</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/VM%E6%8E%92%E6%9F%A51.png" class=""><p>2.检查服务，DHCP是用来发放ip地址的，NAT是用来控制NAT模式虚拟机上网的。</p><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/VM%E6%8E%92%E6%9F%A52.png" class=""><p>还可以检查以下几项：</p><ul><li>检查虚拟机的网络适配器，是否连接，是否为nat模式</li><li>检查VMware Netwrk Adapter VMnet8网卡是否处于禁用状态</li><li>VMnet8网卡的ip地址是否和虚拟机处于同一个网段，有时候手动指定ip地址会写错</li><li>检查虚拟机的ip是否有或者是否正常，linux上ip地址冲突，会导致设置这个ip的主机拿不到这个ip地址</li></ul><p>ping   DNS服务器回显网络不可达 ；有两种情况：</p><ul><li>网关挂了</li><li>网关地址写错了</li></ul><p>能Ping通公网ip,ping不通域名，证明DNS地址有问题</p><p>可以通过vim命令进行修改   </p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vim /etc/resolv.conf   #这里可以直接修改DNS地址<br></code></pre></td></tr></table></figure><img src="/2025/02/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E4%B8%ADDNS%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80.png" class=""><p>物理机上不了网：</p><ul><li>检查物理是否正常</li><li>Ping网关</li><li>ping公网ip</li><li>ping <a href="http://www.baidu.com/">www.baidu.com</a>     tracert -d <a href="http://www.baidu.com/">www.baidu.com</a></li><li>ping自己服务器</li></ul><p>还可能是交换机，路由器，光猫出现的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hexo server --debug   #有时候图片生成不出来那就debug一下就会出来了<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepSeek惨遭DDOS攻击</title>
      <link href="/2025/02/09/%E5%88%9D%E8%AF%86--DDOS%E6%94%BB%E5%87%BB/"/>
      <url>/2025/02/09/%E5%88%9D%E8%AF%86--DDOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p> 首先<strong>DDOS</strong>的缩写是（Distributed Denial of Service，简称DDoS），即分布式拒绝服务，是指黑客将多台计算机联合起来作为攻击平台，通过远程连接，利用恶意程序对一个或多个目标发起DoS攻击，消耗目标服务器性能或网络带宽，从而造成服务器无法正常地提供服务，达到“妨碍正常使用者使用服务”的目的，这样就形成了DDoS攻击。</p><p>它前身是<strong>DOS</strong> (Denial of Service)攻击，其含义是拒绝服务攻击，这种攻击行为使网站服务器充斥大量的要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷而停止提供正常的网络服务。</p><p>而DDOS分布式拒绝服务，则主要利用 Internet上现有机器及系统的漏洞，攻占大量联网主机，使其成为攻击者的代理。当被控制的机器达到一定数量后，攻击者通过发送指令操纵这些攻击机同时向目标主机或网络发起DoS攻击，大量消耗其网络带和系统资源，导致该网络或系统瘫痪或停止提供正常的网络服务。由于DDos的分布式特征，它具有了比Dos远为强大的攻击力和破坏性。</p><p>拒绝服务：拒绝服务是指应用系统无法正常对外提供服务的状态，如网络阻塞、系统宕机、响应缓慢等都属于拒绝服务的表现。</p><p>无论是DOS还是DDOS目的都是利用技术手段消耗目的服务器带宽导致目的服务器拒绝访问。</p><h2 id="DDOS攻击分为三层"><a href="#DDOS攻击分为三层" class="headerlink" title="DDOS攻击分为三层"></a>DDOS攻击分为三层</h2><h4 id="网络层攻击‌"><a href="#网络层攻击‌" class="headerlink" title="网络层攻击‌"></a>网络层攻击‌</h4><p>这类攻击主要针对网络层，旨在消耗网络带宽资源。</p><ul><li><strong>ICMP(internet control message protocol) Flood</strong>：利用大量的ICMP数据包耗尽目标主机的CPU资源。</li></ul><p><strong>工作原理</strong>：</p><ul><li>受害者（充当源IP地址）等着躺枪；且需要响应大量数据包（例如：攻击者发起的是大量ping请求数据包；受害者需要响应大量响应数据包）；导致受害者的服务器带宽和资源被耗尽，甚至可能导致网络阻塞。</li></ul><p><strong>影响</strong>：</p><ul><li>消耗服务器带宽和处理能力，尤其是当目标服务器无法区分合法请求时。</li></ul><p><strong>防御手段</strong>：</p><ul><li>ICMP 请求速率限制：通过防火墙或路由器限制每秒允许的 ICMP 请求数量。</li><li>源地址验证：防止伪造源地址的 ICMP 包。</li><li>禁止 ICMP 响应：对 ICMP Echo 请求进行拦截，禁止 ICMP 回应。</li></ul><hr><ul><li><p><strong>ARP（Address Resolution Protocol ） Flood</strong>：通过发送大量的ARP请求占用网络资源，导致网络拥堵。(IP-&gt;MAC)</p></li><li><p><strong>IP分片攻击</strong>：恶意分片的数据包导致目标网络资源耗尽。</p></li></ul><hr><h4 id="传输层攻击‌"><a href="#传输层攻击‌" class="headerlink" title="传输层攻击‌"></a>传输层攻击‌</h4><p>这类攻击针对传输层，旨在使目标服务器或网络设备过载。常见的传输层攻击包括：</p><ul><li><strong>SYN Flood</strong>：利用TCP的三次握手机制，使服务器处理大量半连接，耗尽资源。</li></ul><p><strong>工作原理：</strong></p><ul><li>攻击者发送大量的 SYN（同步）请求包，伪造源 IP 地址。目标服务器接收到 SYN 请求后，返回一个 SYN-ACK（同步确认）响应，等待 ACK（确认）响应来建立连接。</li><li>攻击者不回应 SYN-ACK 响应，导致目标服务器无法完成 TCP 三次握手，保持连接在半打开状态，消耗大量资源。</li></ul><p><strong>影响：</strong></p><ul><li>服务器为每个半连接分配内存和处理能力，耗尽资源，导致无法处理正常的连接请求。</li></ul><p><strong>防御手段：</strong></p><ul><li>SYN Cookies：通过使用 SYN Cookies 技术来避免为每个半连接分配资源，防止资源耗尽。</li><li>连接队列限制：减少每个服务器能够处理的并发连接数。</li><li>防火墙和负载均衡器：启用防火墙来过滤不必要的 SYN 请求，并使用负载均衡器分散流量。</li></ul><hr><ul><li><strong>ACK Flood</strong>：发送大量带有超大载荷的ACK报文，引起链路拥塞。</li></ul><p><strong>工作原理：</strong></p><ul><li>攻击者发送大量的 ACK（确认）包，这些包会被目标服务器认为是已经建立连接的请求。</li><li>服务器会消耗大量资源来解析这些包，尝试响应它们，而实际上这些 ACK 包没有合法的连接状态。</li></ul><p><strong>影响：</strong></p><ul><li>消耗服务器的计算资源，影响正常的连接请求。</li></ul><p><strong>防御手段：</strong></p><ul><li>基于状态的防火墙：通过防火墙或其他网络设备过滤非法 ACK 包。</li><li>速率限制：限制每个 IP 地址的 ACK 包的发送速率。</li></ul><hr><p><strong>UDP Flood</strong>：充塞目标主机的端口，导致系统失去响应。</p><p><strong>工作原理</strong>：</p><ul><li>攻击者向目标服务器发送大量的 UDP（用户数据报协议） 数据包，通常是伪造的请求数据包。由于 UDP 是无连接的协议，服务器无法验证请求的来源。</li><li>目标服务器收到 UDP 数据包后，会根据请求进行处理并回应，这会消耗大量带宽和计算资源。</li></ul><p><strong>影响：</strong></p><ul><li>消耗带宽和资源，导致目标服务器无法处理正常的请求，服务被中断。</li></ul><p><strong>防御手段：</strong></p><ul><li>防火墙过滤：可以配置防火墙丢弃无效的 UDP 数据包，尤其是没有合法目的地的流量。</li><li>流量分析和速率限制：监控网络流量，设置阈值，自动检测并限制流量。</li><li>基于状态的过滤：仅允许特定端口或协议的 UDP 数据包，减少不必要的流量。</li></ul><hr><h4 id="‌应用层攻击‌"><a href="#‌应用层攻击‌" class="headerlink" title="‌应用层攻击‌"></a>‌应用层攻击‌</h4><p>这类攻击针对应用层，旨在让真实用户无法正常使用应用程序。常见的应用层攻击包括：</p><ul><li><strong>DNS Flood</strong>：破坏DNS解析，导致业务中断。</li></ul><p><strong>工作原理：</strong></p><ul><li>攻击者向目标 DNS 服务器发送大量查询请求，导致服务器消耗大量资源并无法响应合法请求。</li></ul><p><strong>影响：</strong></p><ul><li>目标 DNS 服务器无法为正常用户提供域名解析服务，导致 Web 服务无法访问。</li></ul><p><strong>防御手段：</strong></p><ul><li>DNSSEC：启用 DNS 安全扩展，增加 DNS 的安全性。</li><li>流量监控和速率限制：监控 DNS 请求的频率，限制每秒查询次数。</li></ul><hr><ul><li><strong>HTTP Flood</strong>：发送大量HTTP请求，使服务器无法响应合法流量。</li></ul><p><strong>工作原理：</strong></p><ul><li>攻击者发送大量的 HTTP 请求（例如 GET 或 POST 请求）到目标 Web 服务器，通常是访问页面或提交表单，模拟合法的用户行为。</li><li>由于 HTTP 请求需要 Web 服务器处理，导致服务器消耗大量的计算资源和内存，无法为正常用户提供服务。</li></ul><p><strong>影响：</strong></p><ul><li>对 Web 服务器的资源（如 CPU 和内存）进行大量消耗，使其无法响应正常的请求。</li></ul><p><strong>防御手段：</strong></p><ul><li>WAF（Web 应用防火墙）：部署 WAF 对 HTTP 请求进行检查和过滤，阻止恶意请求。</li><li>速率限制：限制每个 IP 的请求频率，防止单个用户发起大量请求。</li><li>行为分析：通过分析用户行为来识别并拦截恶意流量。</li></ul><hr><ul><li><strong>CC攻击</strong>：模拟网站访问者向服务器发送大量请求，消耗服务器资源。</li></ul><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>一个比较完善的DDos攻击体系主要是由四大部分所组成，分别是<br>（1）主攻击机( attacker也可以称为master)、<br>（2）控制傀儡机( handler)、<br>（3）攻击傀儡机( demon，又可称agent)<br>（4）受攻击机( victim)。</p><pre><code>  其中控制傀儡机和攻击傀儡机，分别用做控制和实际发起攻击。控制傀儡机只发布指令而不参与实际的攻击，攻击傀儡机上发出DDoS的实际攻击包。对第（2）和第（3）部分计算机，主攻击机有控制权或者是部分的控制权，并把相应的DDoS程序上传到这些宿主机上，这些程序与正常的程序一样运行并等待来自主攻击机的指令，通常它还会利用各种手段隐藏自己不被别人发现。在平时，这些傀儡机器并没有什么异常，只是一旦主攻击机连接到它们进行控制并发出指令的时候，攻击愧儡机就成为攻击者去发起攻击了。</code></pre><p><strong>以下是DDOS攻击中DNS 洪水攻击概略图</strong></p><img src="/2025/02/09/%E5%88%9D%E8%AF%86--DDOS%E6%94%BB%E5%87%BB/DDOS.png" class="" title="DDOS"><p>之所以采用这样的结构，一个重要目的是隔离网络联系，保护主攻击机，使其不会在攻击进行时受到攻击防护系统的溯源和跟踪。同时也能够更好地协调进攻，因为攻击执行器的数目太多，同时由一个系统来发布命令会造成控制系统的网络阻塞，影响攻击的突然性和协同性。而且，流量的突然增大也容易暴露攻击者的位置和意图。整个过程可分为：</p><p>（1）扫描大量主机以寻找可入侵主机目标；<br>（2）入侵有安全漏洞的主机并获取控制权；<br>（3）在入侵的主机中安装攻击程序；<br>（4）用己入侵主机继续进行漏洞扫描和入侵；</p><p>当受控制的攻击傀儡机达到主攻击机满意的数量时，主攻击机就可以通过控制傀儡机随时发出攻击指令。由于主攻击机的位置非常灵活，而且发布命令的时间很短，所以非常隐蔽难以定位。一旦攻击的命令传送到攻击傀儡机，主攻击机就可以关闭或脱离网络，以逃避追踪溯源；随着控制傀儡机将命令发布到各个攻击傀儡机，在攻击傀儡机接到攻击命令后，就开始向目标主机发出大量的服务请求数据包。这些数据包经过伪装，使被攻击者无法识别它的来源，这些包所请求的服务往往需要消耗较大的系统资源或网络带宽。如果数百台甚至上千台攻击傀儡机同时攻击一个目标主机，就会导致目标主机网络和系统资源的耗尽，从而停止服务甚至会导致系统崩溃。<br>另外，这样还可以阻塞目标网络的防火墙和路由器等网络设备，进一步加重网络拥塞状况。于是，目标主机根本无法为用户提供任何服务。攻击者所用的协议都是一些非常常见的协议和服务。这样，系统管理员就难于区分恶意请求和正连接请求，从而无法有效分离出攻击数据包。</p><p>对于DDOS攻击防御手段：</p><ul><li>增大流量带宽和容量</li><li>内容识别和过滤</li><li>入侵防御系统（Intrusion Prevention System）IPS   –位于防火墙与网络设备之间；能够有效阻断恶意流量通讯    威胁感知平台</li><li>安全容器云</li><li>高防ip：通过实时监测网络流量，识别并过滤掉恶意流量，将正常流量转发给目标服务器，它通常采用多种技术手段，包括流量清洗、IP黑白名单、速率限制等</li><li>CDN:  分散流量、缓存静态内容、智能过滤恶意流量、提供加密通信、分布式节点、自动缩放、透明缓存和DDoS防护(通过配置策略)。‌</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
